<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://alshedivat.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alshedivat.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-26T19:41:42+00:00</updated><id>https://alshedivat.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">game over</title><link href="https://alshedivat.github.io/blog/2025/gameOver/" rel="alternate" type="text/html" title="game over"/><published>2025-06-18T15:09:01+00:00</published><updated>2025-06-18T15:09:01+00:00</updated><id>https://alshedivat.github.io/blog/2025/gameOver</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/gameOver/"><![CDATA[<p>Next I figured I‚Äôd work on checking if there was a winner or a stalemate. This function would be called my the gameManager.</p> <p>How do you win at Chess? You win if</p> <ol> <li>The opponent is in Check <em>and</em></li> <li>The opponent has no moves which could get them out of Check</li> </ol> <p>There is an alternative outcome is a stalemate. This is when</p> <ol> <li>The opponent is not in Check <em>and</em></li> <li>The opponent has no legal moves</li> </ol> <p>This led me to writing <code class="language-plaintext highlighter-rouge">getAllLegalMoves</code> which checks all the available legal moves for a given color. This is important not just to check for game-ending/stalemate conditions, but also later on when the computer will have to choose its next move (presumably from a list of legal moves or else make sure that it‚Äôs desired move is in the list of legal possibilities.)</p> <p>This function got complicated quickly. Initially, I wrote everything under one massive function until I got to the Queen part and I remembered from the move validator implementation that a Queen is just a rook and a bishop standing on top of eachother under a trench coat, so it really behooves you to write smaller sub functions e.g <code class="language-plaintext highlighter-rouge">getAllRookMoves</code> (not to mention it‚Äôs probably better for debugging/testing).</p> <p>Then, the function iterates over the board and finds the available moves for each piece still on the board. I thought this was preferable to the alternative, the dreaded quadruple for-loop (2 loops to iterate over the board, plus 2 more nested loops to simulate every move moving to each destination square using <code class="language-plaintext highlighter-rouge">pieceCanReach</code>).</p> <h3 id="fen-parsing">FEN Parsing</h3> <p>Rather than start from the standard 8x8 starting position, I realized I needed an empty board that I could stage tests like the Analysis board on chess.com</p> <p>So I added a method to my <code class="language-plaintext highlighter-rouge">Board</code> class to <strong>clear everything</strong> and allow me to place individual pieces manually:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Board</span><span class="o">::</span><span class="n">clearBoard</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The way this is typically done is called FEN (Forsyth-Edwards Notation) strings, which is a very compact notation that captures the state of a chess board at a given instance.</p> <p>What is FEN? It stands for Forsyth-Edwards Notation. It‚Äôs made of 6 space-separated fields</p> <h4 id="1-piece-placement">1. Piece Placement</h4> <p>This is a ‚Äò/‚Äô separated list of 8 ranks where white is capitalized and black is lowercase.</p> <h4 id="2-active-color">2. Active Color</h4> <h4 id="3-castling-availability">3. Castling availability</h4> <h4 id="4-en-passant-target-square">4. En passant target square</h4> <p>This is ‚Äò-‚Äò if none.</p> <h4 id="5-halfmove-clock">5. Halfmove clock</h4> <p>For the 50 move rule</p> <h4 id="6-fullmove-number">6. Fullmove number</h4> <p>Again, some matches have a maximum number of moves so this tracks that</p> <h3 id="simulatemove">simulateMove</h3> <p>I was failing legality tests so there was some debugging with the move validation. To check if a move would leave the king in check, I implemented simulateMove on a cloned board. This let me test hypothetical moves without affecting the real game state.</p> <p>This became essential in: - Checking if castling is legal - Ensuring you don‚Äôt move into check - Verifying forced check escape moves</p> <p>This is what it became:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Board</span><span class="o">::</span><span class="n">loadFEN</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fen</span><span class="p">){</span>
    <span class="n">clearBoard</span><span class="p">();</span>  <span class="c1">// Reset grid to empty</span>

    <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">fen</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">piecePlacement</span><span class="p">,</span> <span class="n">activeColor</span><span class="p">,</span> <span class="n">castling</span><span class="p">,</span> <span class="n">enPassant</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">halfmoveClock</span><span class="p">,</span> <span class="n">fullmoveNumber</span><span class="p">;</span>

    <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">piecePlacement</span> <span class="o">&gt;&gt;</span> <span class="n">activeColor</span> <span class="o">&gt;&gt;</span> <span class="n">castling</span> <span class="o">&gt;&gt;</span> <span class="n">enPassant</span> <span class="o">&gt;&gt;</span> <span class="n">halfmoveClock</span> <span class="o">&gt;&gt;</span> <span class="n">fullmoveNumber</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">piecePlacement</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span> <span class="o">=</span> <span class="n">isupper</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">?</span> <span class="s">"white"</span> <span class="o">:</span> <span class="s">"black"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">row</span><span class="o">++</span><span class="p">;</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">col</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">tolower</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">case</span> <span class="sc">'p'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"pawn"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'n'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"knight"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"bishop"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'r'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"rook"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'q'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"queen"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'k'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"king"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">displayName</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">point_val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="s">"white"</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"pawn"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_P"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"knight"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_N"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"bishop"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_B"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"rook"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_R"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"queen"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_Q"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"king"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_K"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"pawn"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_P"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"knight"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_N"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"bishop"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_B"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"rook"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_R"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"queen"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_Q"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"king"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_K"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;}</span>
            <span class="p">}</span>
            <span class="kt">char</span> <span class="n">file</span> <span class="o">=</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="n">col</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">rank</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">row</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">hasMoved</span> <span class="o">=</span> <span class="n">check_hasMoved</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">castling</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">piece</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Piece</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">displayName</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">point_val</span><span class="p">);</span>
            <span class="n">piece</span><span class="o">-&gt;</span><span class="n">hasMoved</span> <span class="o">=</span> <span class="n">hasMoved</span><span class="p">;</span>

            <span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">piece</span><span class="p">;</span>
            <span class="n">col</span><span class="o">++</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"FEN parsing error: exceeded board bounds."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Done loading FEN this is the board ... "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">printBoard</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">turn</span> <span class="o">=</span> <span class="p">(</span><span class="n">activeColor</span> <span class="o">==</span> <span class="s">"w"</span><span class="p">)</span> <span class="o">?</span> <span class="s">"white"</span> <span class="o">:</span> <span class="s">"black"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">turn</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>I‚Äôve written the unit tests and it passes, but I‚Äôm not fully convinced ‚Ä¶ next I think I want to work on writing the infrastructure for loading in games from available databases and make sure that the moveValidator and checkGameOver are working. I‚Äôll need this either way when I start implementing the part where the computer starts making decisions.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="side-project"/><category term="cpp"/><category term="unit-testing"/><summary type="html"><![CDATA[How to check Win Conditions]]></summary></entry><entry><title type="html">How I Learned to Stop Worrying and Love the Unit Test</title><link href="https://alshedivat.github.io/blog/2025/testing/" rel="alternate" type="text/html" title="How I Learned to Stop Worrying and Love the Unit Test"/><published>2025-06-04T14:28:54+00:00</published><updated>2025-06-04T14:28:54+00:00</updated><id>https://alshedivat.github.io/blog/2025/testing</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/testing/"><![CDATA[<p>‚Ä¶ so does any of this actually work?</p> <p>I learned about Catch2 ‚Ä¶ you just need to include <code class="language-plaintext highlighter-rouge">#define CATCH_CONFIG_MAIN</code> in the header, put your tests in their own directory, then you can run them on their own.</p> <p>In CMakeLists.txt you just need to</p> <h3 id="1-find_package">1. find_package</h3> <p>This tells CMake to look for Catch2 on your system (via CMake‚Äôs module system).</p> <h3 id="2-enable_testing">2. enable_testing()</h3> <h3 id="3-add_executable">3. add_executable</h3> <p>add_executable(test_gameOver tests/test_gameOver.cpp ‚Ä¶) add_executable(test_move_validator tests/test_move_validator.cpp ‚Ä¶)</p> <h3 id="4-target_link_libraries">4. target_link_libraries()</h3> <p>This line links your test executables against Catch2, so you get access to all the Catch2 macros (like TEST_CASE, REQUIRE, etc.).</p> <h3 id="5-add_test">5. add_test</h3> <p>Finally this allows you to run the tests all at once with <code class="language-plaintext highlighter-rouge">ctest</code> or else manually like this <code class="language-plaintext highlighter-rouge">test_gameOver</code></p> <p>My CMakeLists.txt became:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required<span class="o">(</span>VERSION 3.10<span class="o">)</span>
project<span class="o">(</span>chess_bot<span class="o">)</span>

<span class="nb">set</span><span class="o">(</span>CMAKE_CXX_STANDARD 14<span class="o">)</span>
find_package<span class="o">(</span>Catch2 REQUIRED<span class="o">)</span>

include_directories<span class="o">(</span>include
                    external<span class="o">)</span>

add_executable<span class="o">(</span>chess_bot
    main.cpp
    src/board.cpp
    src/piece.cpp
    src/move_validator.cpp
    src/game_manager.cpp
<span class="o">)</span>


<span class="c"># Executable for test_gameOver</span>
add_executable<span class="o">(</span>test_gameOver
    tests/test_gameOver.cpp
    src/board.cpp
    src/piece.cpp
    src/move_validator.cpp
    src/game_manager.cpp
<span class="o">)</span>

<span class="c"># Executable for test_move_validator</span>
add_executable<span class="o">(</span>test_move_validator
    tests/test_move_validator.cpp
    src/board.cpp
    src/piece.cpp
    src/move_validator.cpp
    src/game_manager.cpp
<span class="o">)</span>

enable_testing<span class="o">()</span>

<span class="c"># Link and register tests</span>
target_link_libraries<span class="o">(</span>test_gameOver Catch2::Catch2<span class="o">)</span>
add_test<span class="o">(</span>NAME GameOverTest COMMAND test_gameOver<span class="o">)</span>

target_link_libraries<span class="o">(</span>test_move_validator Catch2::Catch2<span class="o">)</span>
add_test<span class="o">(</span>NAME MoveValidatorTest COMMAND test_move_validator<span class="o">)</span>
</code></pre></div></div> <p>Then I can begin to write the unit tests. A basic test looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_CASE</span><span class="p">(</span><span class="s">"Pawn can move two squares from starting position"</span><span class="p">,</span> <span class="s">"[pawn]"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Board</span> <span class="n">board</span><span class="p">;</span>
    <span class="n">MoveResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">MoveValidator</span><span class="o">::</span><span class="n">isvalidMove</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="s">"e4"</span><span class="p">,</span> <span class="s">"white"</span><span class="p">);</span>
    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">valid</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>I had to think of the range of things that tested - ‚Äúminimal but complete‚Äù as they say.</p> <p>This led me to test one canonical legal move and one canonical illegal move for each major concept: - Each piece type (pawn, knight, rook, bishop, queen, king) - Special moves (castling, en passant, pawn promotion) - Rule enforcement (check, self-check, invalid notation)</p> <p>Here‚Äôs what I came up with so far.</p> <p><strong>Basic legality</strong> TEST_CASE(‚ÄúBasic Pawn Move‚Äù) ensures that standard opening moves work.</p> <p><strong>Illegal vs. legal movement</strong> Ne5 fails (wrong square), Nf3 passes ‚Äî this confirms knight move logic is working as expected.</p> <p><strong>Sliding piece logic</strong> For rooks and bishops, I checked that they can‚Äôt ‚Äúphase‚Äù through other pieces. If Rh3 is blocked, it fails; after clearing the path, it passes.</p> <p><strong>Castling</strong> Separate tests ensure: - Valid king-side and queen-side castling pass when legal - Castling fails if any required condition is violated (e.g., king moved, path not clear, in check)</p> <p><strong>Self-check rules</strong> Moves that leave the king in check are invalid. These are tested with simulated attacks and forced king escapes.</p> <p><strong>Historical rules</strong> Scholars Mate is included as a real-game sequence test ‚Äî testing both correctness and sanity of the move validator when chaining moves.</p> <h2 id="lessons-learned">Lessons Learned</h2> <h3 id="duplicate-san-parsing">Duplicate SAN Parsing</h3> <p>I realized, thanks to many many print statements, that parseSAN was being called multiple times over. I refactored to parse the move once, then pass the parsed move into both steps. SAN notation is weird in that, it doesn‚Äôt give outrightly any info about the departure square - you just have to scan around looking for pieces that <em>could</em> reach the target square. That‚Äôs where our <code class="language-plaintext highlighter-rouge">pieceCanReach</code> from before gets called.</p> <h3 id="better-errors">Better Errors</h3> <p>Instead of <code class="language-plaintext highlighter-rouge">isvalidMove</code> returning bool, I upgraded it to reutn a custom struct <code class="language-plaintext highlighter-rouge">MoveResult</code> so I can more cleanly capture the reason a move failed. In theory, this ensures that unit tests are passing/failing for the reasons they should.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="side-project"/><category term="cpp"/><category term="unit-testing"/><summary type="html"><![CDATA[Unit Testing with Catch2 and Debugging]]></summary></entry><entry><title type="html">The Rules of the Game</title><link href="https://alshedivat.github.io/blog/2025/moveValidation/" rel="alternate" type="text/html" title="The Rules of the Game"/><published>2025-05-05T18:06:12+00:00</published><updated>2025-05-05T18:06:12+00:00</updated><id>https://alshedivat.github.io/blog/2025/moveValidation</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/moveValidation/"><![CDATA[<p>So we have our pieces, we have our board, and we can play a game but how do we enforce the rules?</p> <p>This part of the project seemed trickier. I figured there are 3 parts of validty; valid notation, valid pattern, and move legality.</p> <h2 id="1-notation">1. Notation</h2> <p>Since I chose to make the simplest, dumbest possible interface the user would need to input their desired move by typing on the command line. Rather than invent some way for them to type in their move, I decided to use SAN notation.</p> <p>This is probably the 2nd most accessible way for a human to input their desired move - 2nd only to a graphic interface where you click/drag like chess.com. But I can‚Äôt be bothered right now to do that‚Ä¶ maybe later. I figured we‚Äôd need SAN parsing down the line anyway, maybe to implement some learning from existing databases of famous chess games.</p> <h3 id="san-chess-notation">SAN Chess Notation</h3> <h4 id="example-san-moves">Example SAN moves:</h4> <ul> <li><code class="language-plaintext highlighter-rouge">e4</code> ‚Äî pawn to e4</li> <li><code class="language-plaintext highlighter-rouge">Nf3</code> ‚Äî knight to f3</li> <li><code class="language-plaintext highlighter-rouge">O-O</code> ‚Äî kingside castling</li> <li><code class="language-plaintext highlighter-rouge">Qxe5+</code> ‚Äî queen captures on e5 with check</li> </ul> <p>My validator uses a regular expression to confirm the move matches SAN format.</p> <h2 id="2-move-pattern">2. Move Pattern</h2> <p>This part seemed more fun to me - how can each piece move? How do we encode those rules? This is where the function comes in <code class="language-plaintext highlighter-rouge">pieceCanReach</code></p> <h3 id="pawn">Pawn</h3> <ul> <li>Can move 1 or 2 squares forward from the starting row</li> <li>Captures diagonally</li> </ul> <p>Later, I went back and tried to manage <em>en passant</em> ‚Ä¶ I also need to handle pawn promotion at some point.</p> <p>Does anyone really remember <em>en passant</em>? I don‚Äôt. But I suck at chess. That‚Äôs why I‚Äôm making a robot to beat my husband for me. I tried staring at the Wikipedia for a while but eventually it seemed to come down to this:</p> <ul> <li>The most important thing is that it can only happen after the <em>opponent</em> moves a pawn 2 squares forward. This is helpful to limit the number of chances for <em>passant</em></li> <li>Furthermore, the pawn (the target) that has moved 2 squares must also land beside your pawn.</li> <li>You can capture the target as if it had only moved one square</li> </ul> <p>To encode this is simple. You need only check that</p> <ul> <li>The attacker (your pawn) is capturing</li> <li>There is a target pawn next to it</li> <li>The target pawn has exactly two moves in its history, jumping up two rows</li> </ul> <h3 id="bishop">Bishop</h3> <ul> <li>Moves diagonally, must not be blocked</li> <li>Loops outward along diagonals until it hits something</li> </ul> <h3 id="knight">Knight</h3> <ul> <li>Classic L-shaped moves ‚Äî always 2+1 in any direction</li> <li>Doesn‚Äôt care about obstructions</li> </ul> <h3 id="rook">Rook</h3> <ul> <li>Moves horizontally or vertically</li> <li>Must not be blocked</li> </ul> <h3 id="queen">Queen</h3> <ul> <li>Combines bishop and rook rules</li> </ul> <h3 id="king">King</h3> <ul> <li>Moves one square in any direction</li> <li>Castling is handled specially in the legality check</li> </ul> <h2 id="3-move-legality">3. Move Legality</h2> <p>There are a few rules that come to mind ‚Ä¶</p> <ul> <li>You can‚Äôt move yourself into check</li> <li>If the player is currently in check, they must get themselves out of check <em>that</em> turn</li> <li>You can‚Äôt capture a piece of the same color</li> <li>You can‚Äôt castle yourself out of check</li> </ul> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="side-project"/><category term="cpp"/><summary type="html"><![CDATA[First pass at move validation in my C++ chess bot]]></summary></entry><entry><title type="html">The Beginning Begins</title><link href="https://alshedivat.github.io/blog/2025/theBeginning/" rel="alternate" type="text/html" title="The Beginning Begins"/><published>2025-04-23T12:26:16+00:00</published><updated>2025-04-23T12:26:16+00:00</updated><id>https://alshedivat.github.io/blog/2025/theBeginning</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/theBeginning/"><![CDATA[<h1 id="project-design-building-a-chess-bot-in-c">Project Design: Building a Chess Bot in C++</h1> <p>When I set out to build a chess bot to learn C++ better, I knew I had to start with the foundations: representing the <strong>pieces</strong>, the <strong>board</strong>, and the <strong>game manager</strong> which would be responsible for checking for the winner and managing turns. My goal wasn‚Äôt just to make it work‚ÄîI wanted to build something modular, extensible, and readable.</p> <p>This post walks through how I structured the project in its first phase, and why.</p> <hr/> <h2 id="1-the-piece-class">1. The <code class="language-plaintext highlighter-rouge">Piece</code> Class</h2> <p>The first building block was the <code class="language-plaintext highlighter-rouge">Piece</code> class. Each piece in chess has a name (like <code class="language-plaintext highlighter-rouge">"pawn"</code>), a color (<code class="language-plaintext highlighter-rouge">"white"</code> or <code class="language-plaintext highlighter-rouge">"black"</code>), and a position on the board (both in algebraic notation and row/col index).</p> <p>Besides piece name and color I also added:</p> <ul> <li><code class="language-plaintext highlighter-rouge">hasMoved</code>: to help handle castling and initial pawn moves.</li> <li><code class="language-plaintext highlighter-rouge">moveHistory</code>: a vector of past positions, I only did this because I figured it would be useful for special rules like <strong>en passant</strong>.</li> <li><code class="language-plaintext highlighter-rouge">point_val</code>: rough valuation of the piece, for heuristic determination in the future.</li> </ul> <p>Here‚Äôs the basic constructor:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Piece</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">displayName</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">point_val</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hasMoved</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">moveHistory</span><span class="p">;</span>

    <span class="n">Piece</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">displayName</span><span class="p">,</span>
          <span class="kt">char</span> <span class="n">file</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">point_val</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">hasMoved</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">moveHistory</span><span class="p">);</span>

    <span class="n">Piece</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">displayName</span><span class="p">,</span>
          <span class="kt">char</span> <span class="n">file</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">point_val</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>One thing I learned here is how to write constructors and the utility of convenience constructors. Basically allowing you not have to re-write long constructor calls every time you init a piece.</p> <h2 id="2-the-board-class">2. The <code class="language-plaintext highlighter-rouge">Board</code> Class</h2> <p>This one is easy. You need only a grid of size 8x8. Then we iterate through, assigning pieces where they‚Äôre needed to spots in the grid. The main thing is being able to visualize it. I thought about implementing a cute interface in a window like chess.com but I can‚Äôt be bothered at this point so I went with a much more utilitarian approach where it‚Äôs just printed out on the command line after each turn (hence the display name proprerty in the piece class, which is ‚Äúw_N‚Äù for white knight). This required a lot of fussing with spacing and printing out the rank/file such that they aligned with the rows/columns.</p> <p>I use shared pointers in the grid. What does that mean? Piece objects live on the heap and lets each piece maintain its own state (move history, color, etc.) without copying them over and over. It also means that, while the board owns the piece in the grid square, I can pass it to other functions, like a move validator wihout being concerned about ownership. I don‚Äôt have to worry about memory mangement either.</p> <h2 id="3-the-game-manager-class">3. The <code class="language-plaintext highlighter-rouge">Game Manager</code> Class</h2> <p>The GameManager handles the game loop: alternating turns, taking input, making computer moves, and printing the board. It manages whose turn it is and passes moves to the board for validation and execution.</p> <p>Initally, I just implemented a few functions; <code class="language-plaintext highlighter-rouge">start()</code>, <code class="language-plaintext highlighter-rouge">makeMove</code>, and the public properties; <code class="language-plaintext highlighter-rouge">currentTurn</code>, and <code class="language-plaintext highlighter-rouge">board</code>. Later, I implemented the necessary structure to check for a winner or stalemate, which is more complicated.</p> <hr/> <p>Once these were implemented, we could build and start printing out the board. At this point my main.cpp was just</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">playerColor</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Choose your color (white/black) "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">playerColor</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">playerColor</span> <span class="o">==</span> <span class="s">"white"</span> <span class="o">||</span> <span class="n">playerColor</span> <span class="o">==</span> <span class="s">"black"</span><span class="p">){</span><span class="k">break</span><span class="p">;}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Invalid color. Please write white or black.</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">GameManager</span> <span class="nf">game</span><span class="p">(</span><span class="n">playerColor</span><span class="p">);</span>
    <span class="n">game</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Which simply yields</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/basicInterface-480.webp 480w,/assets/img/basicInterface-800.webp 800w,/assets/img/basicInterface-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/basicInterface.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="GUI" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">For now, this is our chess board.</figcaption> </figure> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="side-project"/><category term="cpp"/><summary type="html"><![CDATA[Starting a side project to explore C++ best practices and RL]]></summary></entry><entry><title type="html">Why ChessBot?</title><link href="https://alshedivat.github.io/blog/2025/whyChessBot/" rel="alternate" type="text/html" title="Why ChessBot?"/><published>2025-04-14T16:40:16+00:00</published><updated>2025-04-14T16:40:16+00:00</updated><id>https://alshedivat.github.io/blog/2025/whyChessBot</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/whyChessBot/"><![CDATA[<p>After wrapping up my PhD in March 2025, I found myself with some downtime. I wanted to take on an ambitious side project to keep me entertained while I looked for a job - something that would challenge my understanding of C++ and give me space to explore best practices outside the context of research or systems engineering.</p> <p>The idea came from a classical technical interview prompt: <em>build a tic-tac-toe game in C++</em>. That basic idea sparked a much bigger one‚Äîwhy not take it (several steps) further and build a full chess engine?</p> <h3 id="why-chess">Why Chess?</h3> <p>Chess offers a rich design space:</p> <ul> <li>A complex set of rules to encode</li> <li>Real-time interaction between a backend and a GUI</li> <li>Opportunities to implement search and reinforcement learning</li> <li>A way to practice interfacing between different components of a software stack</li> </ul> <h3 id="why-now">Why Now?</h3> <p>During the Restorebot project, we initially tried using reinforcement learning to guide seeding decisions in degraded rangelands. But we quickly hit a wall: <strong>none of the microsites we seeded grew that first season</strong>, which meant there was no reward signal to explore. That failure led us to pivot hard toward perception, vision, and long-term SLAM. See our ISER paper if you don‚Äôt know what I‚Äôm talking about (https://arxiv.org/abs/2312.07724).</p> <p>Even though RL has questionable applicability in some industrial contexts‚Äîclients generally aren‚Äôt interested in black-box solutions‚ÄîI‚Äôm still interested in its potential. And besides, chess is a really rich space to explore some other ML techniques as well. We‚Äôll see where it takes me!</p> <h3 id="what-i-hope-to-learn">What I Hope to Learn</h3> <ul> <li>Solid C++ software design, with an emphasis on interfaces and separation of concerns</li> <li>Real-time communication between a backend engine and a frontend GUI</li> <li>Learning more about RL and other ML techniques for decision-making in game environments</li> <li>Managing a medium-size side project like a real software engineer would</li> </ul> <hr/> <p>I‚Äôm hoping this series will be a useful log of what I‚Äôm building, where I hit snags, and what I learn along the way. If nothing else, it‚Äôll be a fun challenge‚Äîand a good excuse to play more chess. And I hope it can be helpful or interesting to someone out there.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="side-project"/><category term="cpp"/><category term="reinforcement-learning"/><summary type="html"><![CDATA[Starting a side project to explore C++ best practices and RL]]></summary></entry></feed>