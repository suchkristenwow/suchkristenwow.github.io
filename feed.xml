<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://alshedivat.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alshedivat.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-08T20:32:50+00:00</updated><id>https://alshedivat.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">A Big-Picture History of Chess Bots</title><link href="https://alshedivat.github.io/blog/2025/gameEngines_primer/" rel="alternate" type="text/html" title="A Big-Picture History of Chess Bots"/><published>2025-07-07T14:06:59+00:00</published><updated>2025-07-07T14:06:59+00:00</updated><id>https://alshedivat.github.io/blog/2025/gameEngines_primer</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/gameEngines_primer/"><![CDATA[<p>We can finally begin on the fun part of writing the part of the engine that actually makes moves!</p> <h3 id="side-tangent-about-my-interest-in-the-history-of-chess-bots">Side Tangent about my Interest in the History of Chess Bots</h3> <p>If you‚Äôre here to follow the technical side of my chess bot development please skip to <em>Early Chess Engines</em>.</p> <p>I really like reading about old chess bots, the people behind them, and how we got to where we are now. There is something so inspiring and endearing to me about nascent computer scientists and engineers between the 50s-80s in particular. It would seem computer science as a field these days has lost some of that mystique and been somewhat perverted by the bro-ey, stone-cold souless capitalist culture that is associated with robotics and AI in industry.</p> <p>I feel that sparkle of romanticism when I watch movies like <em>Hidden Figures</em> or the <em>The Imitation Game</em>. I feel it standing in the Space Center in Houston and see the desks of the CapCom just as they were in July 1969, littered with cigarette butts. They did these things <em>because</em> they were hard (or as I would like to think, useful or good).</p> <p>In case you still can‚Äôt picture it, I‚Äôve been reading <em>Hackers: Heroes of the Computer Revoution</em> by Steve Levy and at the very front of the book is an index of these people with such clever and charming descriptions as:</p> <blockquote> <p><strong>Bob Davis</strong> ‚Äì Left a job in a liquor store to become bestselling author of the Sierra On-Line computer game <em>Ulysses and the Golden Fleece</em>. Success was his downfall.</p> <p><strong>John Draper</strong> ‚Äì The notorious ‚ÄúCaptain Crunch‚Äù who fearlessly explored phone systems, was jailed, and later hacked microcomputers. Cigarettes made him violent.</p> <p><strong>Warren Schwader</strong> ‚Äì Big blond hacker from rural Wisconsin who went from the assembly line to software stardom, but couldn‚Äôt reconcile the shift with his devotion to Jehovah‚Äôs Witnesses.</p> </blockquote> <p>Who wouldn‚Äôt aspire to be like these guys?? Sadly, I feel that characters such as these are a product of a bygone era.</p> <p>At least from what I‚Äôve observed in the academic world, the incentives reward what‚Äôs publishable‚Äînot necessarily what‚Äôs meaningful or important. It‚Äôs often a better strategy to repackage an existing result into multiple papers than to aim to find where our skills and resources can be expanded on to meet big, important challenges. That‚Äôs why I think academic robotics tends to focus on what we can <em>already</em> do rather than what we <em>should</em> do. Not always, but often.</p> <p>As for industry, I‚Äôm both amazed and disillusioned by the scale of models coming out of companies like Meta and Google. The results are impressive, but the reliance on massive private datasets and million dollar compute budgets feels disconnected from the heart of open scientific inquiry. It lacks panache for me.</p> <p>Lest this devolves into one of those recipe blogs that expounds the developer‚Äôs entire family history only to tell you how to hard-boil an egg, I‚Äôll leave it at that. For now I want to learn more about how they did what they did in those supposed ``glory days‚Äù.<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p> <h3 id="early-chess-engines-1950s-1980s">Early Chess Engines (1950s-1980s)</h3> <p>Technically, the first chess bot was a mechanical automaton called El Ajedrecista built by Leonardo Torres Quevedo in 1912 which could play an endgame with the white pieces in which white has a king and a rook, and black only has a king. The machine was capable of mating the black king (played by a human). While mechanically interesting, I think it‚Äôs fair to say that it lacks the kind of intelligence I‚Äôm seeking to develop.</p> <p>The invention of the computer after WWII caused an explosion in chess engines. The foundation was laid by Alan Turing, Claude Shannon and Dietrich Prinz although these early algorithms could not play entire games, mostly due to hardware constraints.</p> <p>That would change in 1957 when IBM engineer Alex Bernstein created the first fully automated chess engine capable of playing an entire game, although it would take about 8 minutes per move on the IBM 704 mainframe. It‚Äôs algorithm followed from the one detailed by Turing, Shannon and Prinz.</p> <p>Chess Engines in this era were based on minimax search, used static evaluation functions, and or alpha-beta pruning. There was also a lot of reliance on handcrafted rules by grandmasters or programmers.</p> <p>The basic idea of classical chess bots is to search the game tree. What that means is, we want to simulate all possible sequences of moves, score each resulting position and then choose the move that leads to the best outcome.</p> <h4 id="minimax">Minimax</h4> <ul> <li>Max node: On your turn, pick the move that gives you the highest evaluation</li> <li>Min node: On your opponents turn, assume they‚Äôll pick the move that gives you the lowest evaluation</li> <li>Repeat to some fixed depth (called the number of plies, where 1 ply = 1 move by either player). This is constrained by your hardware and time, as there are usually about 35 legal moves per position, and the number of positions explodes exponentially with depth. So the work becomes, how do I guide or limit the search to make it run in reasonable time?</li> </ul> <p>The main thing I want to understand more here is how exactly they evaluate each position. Positioning in chess is essential, and when humans say ‚Äúwhite has a better position here‚Äù, we usually are referring to the idea that white has stronger potential for attacking/defense, that is, we evaluate how good ones‚Äô position is based on possible future moves. But doing it that way seems a bit circular if we use position evaluation to do minimax searching.</p> <p>Obviously, material plays in a part in it, but it is only one aspect, an arguably not the most important. Famously, even sacrificing a queen for a superior position can win very high level chess games - <em>see Kasparov‚Äôs Immortal</em>. I‚Äôll circle back on this ‚Ä¶</p> <h4 id="what-is-alpha-beta-pruning">What is Alpha-Beta Pruning</h4> <p>Alpha-beta pruning remains key to chess programming to this day so it‚Äôs important to understand. It‚Äôs an optimization on minimax that works by eliminating branches that don‚Äôt affect the final decision.</p> <p>In the best case, alpha-beta reduces the number of nodes from $O(b^d)$ to $O(\sqrt{b^d})$ where b is the branching factor (35 for the number of legal moves/turn) and d is the search depth (how many turns or plies we want to evaluate in the future). Simply put, we don‚Äôt waste time on considering downstream decisions of bad moves. If move A results in our position eval increasing by 1, and move B results in our position eval increasing by 5 but the subsequent result of move B is check mate, we don‚Äôt need to evaluate outcomes from playing move B.</p> <h4 id="mac-hack">Mac Hack</h4> <p>The first bot to play in a tournament was Mac Hack VI in 1966. Its name comes from Project MAC (Multi-Level Access Computer), a research program at MIT. The number in its name is not because it‚Äôs the sixth of its kind, but because it was written for a PDP-6, a mainframe computer released in 1964.</p> <p>It‚Äôs notable for being the first chess program to be widely distributed and the first chess bot to get a rating. In its first tournament, the Massachusetts Amateur Championship in 1966 it was rated 1243. The peak of its performance was in 1967 when it achieved a rating of 1510 at the same tournament.</p> <h4 id="transposition-tables">Transposition Tables</h4> <p>What made Mac Hack so good? It was the first chess bot to use a transposition table. This is another way to reduce the search space of the chess tree. You can imagine that, when searching over plies of subsequent possible moves, you encounter the same positions over and over again from different sequences of moves. That is, to achieve a unique arrangement of pieces on a board, there are many sequences of moves that could result in that arrangement. These different sequences are called ``transpositions‚Äù.</p> <p>A transposition table is merely a massive hash table which stores information about positions previously searched, how deeply they were searched, and the resulting evaluation. That is, given a board object, we convert it into a unique scalar signature using a hash function that allows us to easily store it in a big sorted dictionary along with the properties; previously searched positions and previous board evaluations.</p> <p>The most commonly used hash function for this purpose is called <em>Zobrist Hashing</em>. Ultimately the board layout, castling rights, and en passant targets are mapped to a unsigned 64-bit integer.</p> <h5 id="zobrist-hashing">Zobrist Hashing</h5> <ol> <li>Precompute random 64-bit integers for every possible piece on every square <ul> <li>12 pieces x 64 squares = 768 entries</li> <li>Plus random numbers for castling rights (16 combinations)</li> </ul> </li> <li>Initialize the hash to 0</li> <li>XOR in the values: <ul> <li>For each piece on the board, XOR the corresponding value</li> <li>XOR in the side-to-move value</li> <li>XOR in castling rights and en passant square</li> </ul> </li> </ol> <p>What does XOR mean for chess pieces? You probably know XOR returns true if <em>only</em> 1 of two items are true. What does that mean for chess pieces?</p> <p>Let‚Äôs say Z[piece][square] gives you a random 64-bit integer for a given piece on a specific square. When you place a piece on the board or remove one we need only do: hash ^= Z[piece][square]</p> <p>That is, suppose we want to put a white pawn on e2:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hash</span> <span class="o">^=</span> <span class="mh">0xABCD1234567890FF</span><span class="p">;</span>
</code></pre></div></div> <p>Then we want to move it:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hash</span> <span class="o">^=</span> <span class="mh">0xABCD1234567890FF</span><span class="p">;</span>  <span class="c1">//hash becomes 0 again</span>
</code></pre></div></div> <p>This works because XOR-ing the same value twice cancels it out.</p> <p>The way we avoid hash collision is fascinating and worth a read but I don‚Äôt want to get into it further here ‚Ä¶</p> <p>In my next post I‚Äôll share my first pass at a late 60s inspired chess bot. Stay tuned.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p>When I refer to glory days, please know I refer to when it seems like people in my field were more likely to take on big important challenges in AI in a way that <em>seems</em> at least naively to have more integrity, and I do not mean to glorify a time when anyone who was not a white, straight cis-man would be lucky to gain even basic respect in these circles, much less be afforded any one of the many opportunities I have enjoyed in my career.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><category term="AI-history"/><summary type="html"><![CDATA[I delve into the world of chess bots, beginning with the classics.]]></summary></entry><entry><title type="html">PGN Replay</title><link href="https://alshedivat.github.io/blog/2025/pgn_replay/" rel="alternate" type="text/html" title="PGN Replay"/><published>2025-06-30T10:16:23+00:00</published><updated>2025-06-30T10:16:23+00:00</updated><id>https://alshedivat.github.io/blog/2025/pgn_replay</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/pgn_replay/"><![CDATA[<p>I was right to be suspicious, dear reader.</p> <p>To really put my move validation and end-game condition checker to the test I wanted to run some actual games.</p> <p>Chess games are recorded in PGN files which contain a list of moves played in SAN (standard algebraic notation) as well as the result.</p> <p>First, I parse these files and use regex to extract the moves. Then I create a GameManager instance and begin iterating over the moves. I check the move validity and the call movePiece. Then I check the game result status. First, I tried on a random game (Garry Kasparov vs. Jorden van Foreest 2021) from chess.com and found substantial problems with the disambiguation logic. In particular, the move bxc6 parsed as <strong>bishop</strong> takes on c6 which of course is not a valid move.</p> <p>I ended up solving this by changing parseSAN to look for candidate pieces - most moves come up with only one candidate but for ones that have more than one candidate, it checks which candidate piece could legally move to the target square.</p> <p>The other problem I found is that movePiece didn‚Äôt actually move the rook and the king during castling, so a special case had to be added to handle that. I similarly had to implement pawn promotion in this function as well.</p> <p>Additionally, isValidPassant had to be changed to allow en passant to <strong>only</strong> when the capturing pawn moved two squares and when the capturing pawn attempts a diagonal capture to an empty square.</p> <p>With these changes, I was able to replay several famous games (including Ivanchuk vs. Wolff 1995 a famous example of en passant) as well as some home-brewed examples of special cases using the analysis board on chess.com</p> <p>Now that I‚Äôve successfuly passed the unit tests and replayed a handful of games, I have more confidence that the bones of the chess engine are good.</p> <p>Next, we can get into actually working on the part where the computer makes moves!</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><category term="unit-testing"/><summary type="html"><![CDATA[Using actual games to check move validation]]></summary></entry><entry><title type="html">game over</title><link href="https://alshedivat.github.io/blog/2025/gameOver/" rel="alternate" type="text/html" title="game over"/><published>2025-06-18T15:09:01+00:00</published><updated>2025-06-18T15:09:01+00:00</updated><id>https://alshedivat.github.io/blog/2025/gameOver</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/gameOver/"><![CDATA[<p>Next I figured I‚Äôd work on checking if there was a winner or a stalemate. This function would be called by the gameManager.</p> <p>How do you win at Chess? You win if</p> <ol> <li>The opponent is in Check <em>and</em></li> <li>The opponent has no moves which could get them out of Check</li> </ol> <p>There is an alternative outcome is a stalemate. This is when</p> <ol> <li>The opponent is not in Check <em>and</em></li> <li>The opponent has no legal moves</li> </ol> <p>This led me to writing <code class="language-plaintext highlighter-rouge">getAllLegalMoves</code> which checks all the available legal moves for a given color. This is important not just to check for game-ending/stalemate conditions, but also later on when the computer will have to choose its next move (presumably from a list of legal moves or else make sure that it‚Äôs desired move is in the list of legal possibilities).</p> <p>This function got complicated quickly. Initially, I wrote everything under one massive function until I got to the Queen part and I remembered from the move validator implementation that a Queen is just a rook and a bishop standing on top of each other under a trench coat, so it really behooves you to write smaller sub functions e.g <code class="language-plaintext highlighter-rouge">getAllRookMoves</code> (not to mention it‚Äôs probably better for debugging/testing).</p> <p>Then, the function iterates over the board and finds the available moves for each piece still on the board. I thought this was preferable to the alternative, the dreaded quadruple for-loop (2 loops to iterate over the board, plus 2 more nested loops to simulate every move moving to each destination square using <code class="language-plaintext highlighter-rouge">pieceCanReach</code>).</p> <h3 id="fen-parsing">FEN Parsing</h3> <p>Rather than start from the standard 8x8 starting position, I realized I needed an empty board that I could stage tests like the Analysis board on chess.com</p> <p>So I added a method to my <code class="language-plaintext highlighter-rouge">Board</code> class to clear everything and allow me to place individual pieces manually</p> <p>The way this is typically done is called FEN (Forsyth-Edwards Notation) strings, which is a very compact notation that captures the state of a chess board at a given instance.</p> <p>What is FEN? It‚Äôs made of 6 space-separated fields</p> <h4 id="1-piece-placement">1. Piece Placement</h4> <p>This is a ‚Äò/‚Äô separated list of 8 ranks where white is capitalized and black is lowercase.</p> <h4 id="2-active-color">2. Active Color</h4> <h4 id="3-castling-availability">3. Castling availability</h4> <h4 id="4-en-passant-target-square">4. En passant target square</h4> <p>This is ‚Äò-‚Äò if none.</p> <h4 id="5-halfmove-clock">5. Halfmove clock</h4> <p>For the 50 move rule</p> <h4 id="6-fullmove-number">6. Fullmove number</h4> <p>Again, some matches have a maximum number of moves so this tracks that</p> <p>Using input streams, I can extract the location, color, and name of each piece on the board. This is what it looks like:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">piecePlacement</span> <span class="o">&gt;&gt;</span> <span class="n">activeColor</span> <span class="o">&gt;&gt;</span> <span class="n">castling</span> <span class="o">&gt;&gt;</span> <span class="n">enPassant</span> <span class="o">&gt;&gt;</span> <span class="n">halfmoveClock</span> <span class="o">&gt;&gt;</span> <span class="n">fullmoveNumber</span><span class="p">;</span>
</code></pre></div></div> <p>Then I iterate over the piecePlacement and init the corresponding piece where it‚Äôs meant to be.</p> <p>This is what the function became:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Board</span><span class="o">::</span><span class="n">loadFEN</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fen</span><span class="p">){</span>
    <span class="n">clearBoard</span><span class="p">();</span>  <span class="c1">// Reset grid to empty</span>

    <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">fen</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">piecePlacement</span><span class="p">,</span> <span class="n">activeColor</span><span class="p">,</span> <span class="n">castling</span><span class="p">,</span> <span class="n">enPassant</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">halfmoveClock</span><span class="p">,</span> <span class="n">fullmoveNumber</span><span class="p">;</span>

    <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">piecePlacement</span> <span class="o">&gt;&gt;</span> <span class="n">activeColor</span> <span class="o">&gt;&gt;</span> <span class="n">castling</span> <span class="o">&gt;&gt;</span> <span class="n">enPassant</span> <span class="o">&gt;&gt;</span> <span class="n">halfmoveClock</span> <span class="o">&gt;&gt;</span> <span class="n">fullmoveNumber</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">piecePlacement</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span> <span class="o">=</span> <span class="n">isupper</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">?</span> <span class="s">"white"</span> <span class="o">:</span> <span class="s">"black"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">row</span><span class="o">++</span><span class="p">;</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">col</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">tolower</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">case</span> <span class="sc">'p'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"pawn"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'n'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"knight"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"bishop"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'r'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"rook"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'q'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"queen"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'k'</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"king"</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">displayName</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">point_val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="s">"white"</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"pawn"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_P"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"knight"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_N"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"bishop"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_B"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"rook"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_R"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"queen"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_Q"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"king"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"w_K"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"pawn"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_P"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"knight"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_N"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"bishop"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_B"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"rook"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_R"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"queen"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_Q"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">"king"</span><span class="p">){</span><span class="n">displayName</span> <span class="o">=</span> <span class="s">"b_K"</span><span class="p">;</span> <span class="n">point_val</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;}</span>
            <span class="p">}</span>
            <span class="kt">char</span> <span class="n">file</span> <span class="o">=</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="n">col</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">rank</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">row</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">hasMoved</span> <span class="o">=</span> <span class="n">check_hasMoved</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">castling</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">piece</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Piece</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">displayName</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">point_val</span><span class="p">);</span>
            <span class="n">piece</span><span class="o">-&gt;</span><span class="n">hasMoved</span> <span class="o">=</span> <span class="n">hasMoved</span><span class="p">;</span>

            <span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">piece</span><span class="p">;</span>
            <span class="n">col</span><span class="o">++</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">row</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"FEN parsing error: exceeded board bounds."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Done loading FEN this is the board ... "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">printBoard</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">turn</span> <span class="o">=</span> <span class="p">(</span><span class="n">activeColor</span> <span class="o">==</span> <span class="s">"w"</span><span class="p">)</span> <span class="o">?</span> <span class="s">"white"</span> <span class="o">:</span> <span class="s">"black"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">turn</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>I‚Äôve written the unit tests and it passes, but I‚Äôm not fully convinced ‚Ä¶ next I think I want to work on writing the infrastructure for loading in games from available databases and make sure that the moveValidator and checkGameOver are working. I‚Äôll need this either way when I start implementing the part where the computer starts making decisions.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><category term="unit-testing"/><summary type="html"><![CDATA[How to check Win Conditions]]></summary></entry><entry><title type="html">How I Learned to Stop Worrying and Love the Unit Test</title><link href="https://alshedivat.github.io/blog/2025/testing/" rel="alternate" type="text/html" title="How I Learned to Stop Worrying and Love the Unit Test"/><published>2025-06-04T14:28:54+00:00</published><updated>2025-06-04T14:28:54+00:00</updated><id>https://alshedivat.github.io/blog/2025/testing</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/testing/"><![CDATA[<p>‚Ä¶ so does any of this actually work?</p> <p>I learned about Catch2 ‚Ä¶ you just need to include <code class="language-plaintext highlighter-rouge">#define CATCH_CONFIG_MAIN</code> in the header, put your tests in their own directory, then you can run them on their own.</p> <p>In CMakeLists.txt you just need to</p> <h3 id="1-find_package">1. find_package</h3> <p>This tells CMake to look for Catch2 on your system (via CMake‚Äôs module system).</p> <h3 id="2-enable_testing">2. enable_testing()</h3> <h3 id="3-add_executable">3. add_executable</h3> <p>add_executable(test_gameOver tests/test_gameOver.cpp ‚Ä¶) add_executable(test_move_validator tests/test_move_validator.cpp ‚Ä¶)</p> <h3 id="4-target_link_libraries">4. target_link_libraries()</h3> <p>This line links your test executables against Catch2, so you get access to all the Catch2 macros (like TEST_CASE, REQUIRE, etc.).</p> <h3 id="5-add_test">5. add_test</h3> <p>Finally this allows you to run the tests all at once with <code class="language-plaintext highlighter-rouge">ctest</code> or else manually like this <code class="language-plaintext highlighter-rouge">test_gameOver</code></p> <p>My CMakeLists.txt became:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required<span class="o">(</span>VERSION 3.10<span class="o">)</span>
project<span class="o">(</span>chess_bot<span class="o">)</span>

<span class="nb">set</span><span class="o">(</span>CMAKE_CXX_STANDARD 14<span class="o">)</span>
find_package<span class="o">(</span>Catch2 REQUIRED<span class="o">)</span>

include_directories<span class="o">(</span>include
                    external<span class="o">)</span>

add_executable<span class="o">(</span>chess_bot
    main.cpp
    src/board.cpp
    src/piece.cpp
    src/move_validator.cpp
    src/game_manager.cpp
<span class="o">)</span>


<span class="c"># Executable for test_gameOver</span>
add_executable<span class="o">(</span>test_gameOver
    tests/test_gameOver.cpp
    src/board.cpp
    src/piece.cpp
    src/move_validator.cpp
    src/game_manager.cpp
<span class="o">)</span>

<span class="c"># Executable for test_move_validator</span>
add_executable<span class="o">(</span>test_move_validator
    tests/test_move_validator.cpp
    src/board.cpp
    src/piece.cpp
    src/move_validator.cpp
    src/game_manager.cpp
<span class="o">)</span>

enable_testing<span class="o">()</span>

<span class="c"># Link and register tests</span>
target_link_libraries<span class="o">(</span>test_gameOver Catch2::Catch2<span class="o">)</span>
add_test<span class="o">(</span>NAME GameOverTest COMMAND test_gameOver<span class="o">)</span>

target_link_libraries<span class="o">(</span>test_move_validator Catch2::Catch2<span class="o">)</span>
add_test<span class="o">(</span>NAME MoveValidatorTest COMMAND test_move_validator<span class="o">)</span>
</code></pre></div></div> <p>Then I can begin to write the unit tests. A basic test looks like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_CASE</span><span class="p">(</span><span class="s">"Pawn can move two squares from starting position"</span><span class="p">,</span> <span class="s">"[pawn]"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Board</span> <span class="n">board</span><span class="p">;</span>
    <span class="n">MoveResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">MoveValidator</span><span class="o">::</span><span class="n">isvalidMove</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="s">"e4"</span><span class="p">,</span> <span class="s">"white"</span><span class="p">);</span>
    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">valid</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>I had to think of the range of things that should be tested - ‚Äúminimal but complete‚Äù as they say.</p> <p>This led me to test one canonical legal move and one canonical illegal move for each major concept: - Each piece type (pawn, knight, rook, bishop, queen, king) - Special moves (castling, en passant, pawn promotion) - Rule enforcement (check, self-check, invalid notation)</p> <p>Here‚Äôs what I came up with so far.</p> <p><strong>Basic legality</strong> TEST_CASE(‚ÄúBasic Pawn Move‚Äù) ensures that standard opening moves work.</p> <p><strong>Illegal vs. legal movement</strong> Ne5 fails (wrong square), Nf3 passes ‚Äî this confirms knight move logic is working as expected. That is, the correct pattern.</p> <p><strong>Sliding piece logic</strong> For rooks and bishops, I checked that they can‚Äôt ‚Äúphase‚Äù through other pieces. If Rh3 is blocked, it fails; after clearing the path, it passes.</p> <p><strong>Castling</strong> Separate tests ensure: - Valid king-side and queen-side castling pass when legal - Castling fails if any required condition is violated (e.g., king moved, path not clear, in check)</p> <p><strong>Self-check rules</strong> Moves that leave the king in check are invalid. These are tested with simulated attacks and forced king escapes.</p> <h2 id="lessons-learned">Lessons Learned</h2> <h3 id="duplicate-san-parsing">Duplicate SAN Parsing</h3> <p>I realized, thanks to many many print statements, that parseSAN was being called multiple times over. I refactored to parse the move once, then pass the parsed move into both steps. SAN notation is weird in that, it doesn‚Äôt give outrightly any info about the departure square - you just have to scan around looking for pieces that <em>could</em> reach the target square. That‚Äôs where our <code class="language-plaintext highlighter-rouge">pieceCanReach</code> from before gets called.</p> <h3 id="better-errors">Better Errors</h3> <p>Instead of <code class="language-plaintext highlighter-rouge">isvalidMove</code> returning bool, I upgraded it to reutn a custom struct <code class="language-plaintext highlighter-rouge">MoveResult</code> so I can more cleanly capture the reason a move failed. In theory, this ensures that unit tests are passing/failing for the reasons they should.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><category term="unit-testing"/><summary type="html"><![CDATA[Unit Testing with Catch2 and Debugging]]></summary></entry><entry><title type="html">The Rules of the Game</title><link href="https://alshedivat.github.io/blog/2025/moveValidation/" rel="alternate" type="text/html" title="The Rules of the Game"/><published>2025-05-05T18:06:12+00:00</published><updated>2025-05-05T18:06:12+00:00</updated><id>https://alshedivat.github.io/blog/2025/moveValidation</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/moveValidation/"><![CDATA[<p>So we have our pieces, we have our board, and we can play a game but how do we enforce the rules?</p> <p>This part of the project seemed trickier. I figured there are 3 parts of validty; valid notation, valid pattern, and move legality.</p> <h2 id="1-notation">1. Notation</h2> <p>Since I chose to make the simplest, dumbest possible interface the user would need to input their desired move by typing on the command line. Rather than invent some way for them to type in their move using matrix coordinates, I decided to use SAN notation.</p> <p>This is probably the 2nd most accessible way for a human to input their desired move - 2nd only to a graphic interface where you click/drag like chess.com. But I can‚Äôt be bothered right now to do that‚Ä¶ maybe later. I figured we‚Äôd need SAN parsing down the line anyway, maybe to implement some learning from existing databases of famous chess games.</p> <h3 id="san-chess-notation">SAN Chess Notation</h3> <h4 id="example-san-moves">Example SAN moves:</h4> <ul> <li><code class="language-plaintext highlighter-rouge">e4</code> ‚Äî pawn to e4</li> <li><code class="language-plaintext highlighter-rouge">Nf3</code> ‚Äî knight to f3</li> <li><code class="language-plaintext highlighter-rouge">O-O</code> ‚Äî kingside castling</li> <li><code class="language-plaintext highlighter-rouge">Qxe5+</code> ‚Äî queen captures on e5 with check</li> </ul> <p>My validator uses a regular expression to confirm the move matches SAN format.</p> <h2 id="2-move-pattern">2. Move Pattern</h2> <p>This part seemed more fun to me - how can each piece move? How do we encode those rules? This is where the function comes in <code class="language-plaintext highlighter-rouge">pieceCanReach</code></p> <h3 id="pawn">Pawn</h3> <ul> <li>Can move 1 or 2 squares forward from the starting row</li> <li>Captures diagonally</li> </ul> <p>Later, I went back and tried to manage <em>en passant</em> ‚Ä¶ I also need to handle pawn promotion at some point.</p> <p>Does anyone really remember how <em>en passant</em> is supposed to work? I don‚Äôt. But I suck at chess. That‚Äôs why I‚Äôm making a robot to beat my husband for me. I tried staring at the Wikipedia for a while but eventually it seemed to come down to this:</p> <ul> <li>The most important thing is that it can only happen after the <em>opponent</em> moves a pawn 2 squares forward. This is helpful to limit the number of chances for <em>passant</em></li> <li>Furthermore, the pawn (the target) that has moved 2 squares must also land beside your pawn.</li> <li>You can capture the target as if it had only moved one square</li> </ul> <p>To encode this is simple. You need only check that</p> <ul> <li>The attacker (your pawn) is capturing</li> <li>There is a target pawn next to it</li> <li>The target pawn has exactly two moves in its history, jumping up two rows</li> </ul> <p>The rest of the pieces are more simple</p> <h3 id="bishop">Bishop</h3> <ul> <li>Moves diagonally, must not be blocked</li> <li>Loops outward along diagonals until it hits something</li> </ul> <h3 id="knight">Knight</h3> <ul> <li>Classic L-shaped moves ‚Äî always 2+1 in any direction</li> <li>Doesn‚Äôt care about obstructions</li> </ul> <h3 id="rook">Rook</h3> <ul> <li>Moves horizontally or vertically</li> <li>Must not be blocked</li> </ul> <h3 id="queen">Queen</h3> <ul> <li>Combines bishop and rook rules</li> </ul> <h3 id="king">King</h3> <ul> <li>Moves one square in any direction</li> <li>Castling is handled specially in the legality check</li> </ul> <h2 id="3-move-legality">3. Move Legality</h2> <p>There are a few rules that come to mind ‚Ä¶</p> <ul> <li>You can‚Äôt move yourself into check</li> <li>If the player is currently in check, they must get themselves out of check <em>that</em> turn</li> <li>You can‚Äôt capture a piece of the same color</li> <li>You can‚Äôt castle yourself out of check</li> </ul> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><summary type="html"><![CDATA[First pass at move validation in my C++ chess bot]]></summary></entry><entry><title type="html">The Beginning Begins</title><link href="https://alshedivat.github.io/blog/2025/theBeginning/" rel="alternate" type="text/html" title="The Beginning Begins"/><published>2025-04-23T12:26:16+00:00</published><updated>2025-04-23T12:26:16+00:00</updated><id>https://alshedivat.github.io/blog/2025/theBeginning</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/theBeginning/"><![CDATA[<h1 id="project-design-building-a-chess-bot-in-c">Project Design: Building a Chess Bot in C++</h1> <p>When I set out to build a chess bot to learn C++ better, I knew I had to start with the foundations: representing the <strong>pieces</strong>, the <strong>board</strong>, and the <strong>game manager</strong> which would be responsible for checking for the winner and managing turns.</p> <p>This post walks through how I structured the project in its first phase, and why.</p> <hr/> <h2 id="1-the-piece-class">1. The <code class="language-plaintext highlighter-rouge">Piece</code> Class</h2> <p>The first building block was the <code class="language-plaintext highlighter-rouge">Piece</code> class. Each piece in chess has a name (like ‚Äúpawn‚Äù), a color (‚Äúwhite‚Äù or ‚Äúblack‚Äù), and a position on the board (both in algebraic notation and row/col index).</p> <p>Besides piece name and color I also added:</p> <ul> <li><code class="language-plaintext highlighter-rouge">hasMoved</code>: to help handle castling and initial pawn moves.</li> <li><code class="language-plaintext highlighter-rouge">moveHistory</code>: a vector of past positions, I only did this after I considering special rules like <strong>en passant</strong>.</li> <li><code class="language-plaintext highlighter-rouge">point_val</code>: rough valuation of the piece, for heuristic determination in the future.</li> </ul> <p>Here‚Äôs the basic constructor:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Piece</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">displayName</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">point_val</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hasMoved</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">moveHistory</span><span class="p">;</span>

    <span class="n">Piece</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">displayName</span><span class="p">,</span>
          <span class="kt">char</span> <span class="n">file</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">point_val</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">hasMoved</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">moveHistory</span><span class="p">);</span>

    <span class="n">Piece</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">displayName</span><span class="p">,</span>
          <span class="kt">char</span> <span class="n">file</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">point_val</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>One thing I learned here is how to write constructors and the utility of convenience constructors. Basically allowing you not have to re-write long constructor calls every time you init a piece.</p> <h2 id="2-the-board-class">2. The <code class="language-plaintext highlighter-rouge">Board</code> Class</h2> <p>This one is easy. You need only a grid of size 8x8. Then we iterate through, assigning pieces where they‚Äôre needed to spots in the grid. The main thing is being able to visualize it. I thought about implementing a cute interface in a window like chess.com but I can‚Äôt be bothered at this point so I went with a much more utilitarian approach where it‚Äôs just printed out on the command line after each turn (hence the display name property in the piece class, which is ‚Äúw_N‚Äù for white knight). This required a lot of fussing with spacing and printing out the rank/file such that they aligned with the rows/columns.</p> <p>I use shared pointers in the grid. What does that mean? Piece objects live on the heap and lets each piece maintain its own state (move history, color, etc.) without copying them over and over. It also means that, while the board owns the piece in the grid square, I can pass it to other functions, like a move validator wihout being concerned about ownership. And I don‚Äôt think I will have to worry about memory management either.</p> <h2 id="3-the-game-manager-class">3. The <code class="language-plaintext highlighter-rouge">Game Manager</code> Class</h2> <p>The GameManager handles the game loop: alternating turns, taking input, making computer moves, and printing the board. It manages whose turn it is and passes moves to the board for validation and execution.</p> <p>Initially, I just implemented a few functions; <code class="language-plaintext highlighter-rouge">start()</code>, <code class="language-plaintext highlighter-rouge">makeMove</code>, and the public properties; <code class="language-plaintext highlighter-rouge">currentTurn</code>, and <code class="language-plaintext highlighter-rouge">board</code>. Later, I implemented the necessary structure to check for a winner or stalemate, which is more complicated.</p> <hr/> <p>Once these were implemented, we could build and start printing out the board. At this point my main.cpp was just</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">playerColor</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Choose your color (white/black) "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">playerColor</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">playerColor</span> <span class="o">==</span> <span class="s">"white"</span> <span class="o">||</span> <span class="n">playerColor</span> <span class="o">==</span> <span class="s">"black"</span><span class="p">){</span><span class="k">break</span><span class="p">;}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Invalid color. Please write white or black.</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">GameManager</span> <span class="nf">game</span><span class="p">(</span><span class="n">playerColor</span><span class="p">);</span>
    <span class="n">game</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Which simply yields:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/basicInterface-480.webp 480w,/assets/img/basicInterface-800.webp 800w,/assets/img/basicInterface-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/basicInterface.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="GUI" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">For now, this is our chess board.</figcaption> </figure> <p>We have a chess board. We have some pieces. Let‚Äôs play! Next we can work on coding up the rules‚Ä¶</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><summary type="html"><![CDATA[Starting a side project to explore C++ best practices and RL]]></summary></entry><entry><title type="html">Why ChessBot?</title><link href="https://alshedivat.github.io/blog/2025/whyChessBot/" rel="alternate" type="text/html" title="Why ChessBot?"/><published>2025-04-14T16:40:16+00:00</published><updated>2025-04-14T16:40:16+00:00</updated><id>https://alshedivat.github.io/blog/2025/whyChessBot</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/whyChessBot/"><![CDATA[<p>After wrapping up my PhD in March 2025, I found myself with some downtime. I wanted to take on an ambitious side project to keep me entertained while I looked for a job - something that would challenge my understanding of C++ and give me space to explore best practices outside the context of research or systems engineering.</p> <p>The idea came from a classical technical interview prompt: <em>build a tic-tac-toe game in C++</em>. That basic idea sparked a much bigger one‚Äîwhy not take it (several steps) further and build a full chess engine?</p> <h3 id="why-chess">Why Chess?</h3> <p>Chess offers a rich design space:</p> <ul> <li>A complex set of rules to encode</li> <li>Real-time interaction between a backend and a GUI</li> <li>Opportunities to implement search and reinforcement learning</li> <li>A way to practice interfacing between different components of a software stack</li> </ul> <h3 id="why-now">Why Now?</h3> <p>During the Restorebot project, we initially tried using reinforcement learning to guide seeding decisions in degraded rangelands. But we quickly hit a wall: <strong>none of the microsites we seeded grew that first season</strong>, which meant there was no reward signal to explore. That failure led us to pivot hard toward perception, vision, and long-term SLAM. See our ISER paper if you don‚Äôt know what I‚Äôm talking about (https://arxiv.org/abs/2312.07724).</p> <p>Even though RL has questionable applicability in some industrial contexts‚Äîclients generally aren‚Äôt interested in black-box solutions‚ÄîI‚Äôm still interested in its potential. And besides, chess is a really rich space to explore some other ML techniques as well. We‚Äôll see where it takes me!</p> <h3 id="what-i-hope-to-learn">What I Hope to Learn</h3> <ul> <li>Solid C++ software design, with an emphasis on interfaces and separation of concerns</li> <li>Real-time communication between a backend engine and a frontend GUI</li> <li>Learning more about RL and other ML techniques for decision-making in game environments</li> <li>Managing a medium-size side project like a real software engineer would</li> </ul> <hr/> <p>I‚Äôm hoping this series will be a useful log of what I‚Äôm building, and what I learn along the way. If nothing else, I hope it can be helpful or interesting to someone out there.</p> <p>üëâ Follow along with my progress on GitHub: <a href="https://github.com/suchkristenwow/chessBot">chessBot</a></p>]]></content><author><name></name></author><category term="side-projects"/><category term="chess-bot"/><category term="cpp"/><category term="reinforcement-learning"/><summary type="html"><![CDATA[Starting a side project to explore C++ best practices and RL]]></summary></entry></feed>